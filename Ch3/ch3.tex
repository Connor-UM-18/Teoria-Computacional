\chapter{Conclusión}

La práctica del palíndromo ha permitido desarrollar un programa en Python que genera y guarda palíndromos en archivos de texto. El programa utiliza reglas predefinidas para construir los palíndromos y muestra el progreso de la construcción en el archivo $"$construccion.txt$"$. Además, guarda la información final del palíndromo en el archivo $"$palindromos.txt$"$.\newline

Durante la implementación, se ha utilizado la manipulación de cadenas, estructuras de control condicionales y bucles para generar los palíndromos de acuerdo con las reglas establecidas. También se han empleado funciones para modularizar y reutilizar el código, mejorando la legibilidad y mantenibilidad del programa.\newline

La práctica ha permitido practicar el uso de archivos de texto para el almacenamiento de información y la escritura de datos en ellos. Además, ha brindado la oportunidad de trabajar con la entrada del usuario y tomar decisiones basadas en ella.\newline
\\

\section{Problemas iniciales}
Inicialmente, me enfrenté a algunos problemas al realizar la práctica del palíndromo. Uno de los desafíos iniciales fue comprender completamente el enunciado y los requisitos del problema. Requería generar palíndromos y guardarlos en archivos de texto, lo cual implicaba la necesidad de manejar correctamente las cadenas, manipular archivos y escribir datos en ellos.\newline

Además, surgió la dificultad de determinar el enfoque adecuado para generar los palíndromos. Tuvimos que analizar las reglas proporcionadas en el código y comprender cómo utilizarlas para construir los palíndromos de manera efectiva. Esto implicó la necesidad de implementar bucles, condicionales y manipulación de cadenas de manera adecuada.\newline

Otro problema al que nos enfrentamos fue la organización del código y la modularización. Dado que el problema requería varias funciones y la interacción con múltiples archivos, fue crucial definir adecuadamente las funciones y establecer una estructura lógica clara para el programa. Esto nos permitió reutilizar código y facilitó el mantenimiento y la legibilidad del programa.\newline

\subsection{Soluciones}
Durante la realización de la práctica del palíndromo, encontré diversas soluciones para abordar los desafíos que se presentaron.\newline

En primer lugar, para comprender completamente el enunciado y los requisitos del problema, me aseguré de leer cuidadosamente el enunciado y analizar las reglas proporcionadas en el código. Utilicé comentarios y anotaciones para destacar los puntos clave y asegurarme de entender cómo generar los palíndromos y guardarlos en archivos de texto.\newline

En cuanto a la generación de palíndromos, implementé una función llamada generar\_palindromo que utilizaba las reglas proporcionadas en el enunciado. Esta función se encargaba de construir los palíndromos de manera iterativa, siguiendo las reglas y reemplazando las letras correspondientes. Utilicé bucles, condicionales y manipulación de cadenas para lograrlo.\newline

Para organizar el código y facilitar su mantenimiento, modularicé el programa en diferentes funciones. Además de la función generar\_palindromo, creé las funciones guardar\_en\_archivo y guardar\_en\_archivo2 para escribir los datos en los archivos de texto. Esto me permitió separar las responsabilidades y reutilizar el código de manera eficiente.\newline


\section{Complejidades}
A continuación, se presentan los límites de complejidad asociados a esta implementación:
\begin{enumerate}
    
\item Complejidad de tiempo: La generación de palíndromos aleatorios implica la selección de reglas de producción de manera aleatoria y la construcción iterativa del palíndromo. El bucle principal del programa tiene una estructura de control que evalúa diferentes casos según la longitud del palíndromo deseado. Por lo tanto, la complejidad de tiempo del programa está relacionada con la longitud del palíndromo especificado por el usuario.\newline

\item Mejor caso: El mejor caso ocurre cuando se ingresa una longitud de palíndromo igual a cero, en cuyo caso el programa termina de inmediato con una complejidad de tiempo constante. O cuando se selecciona la opción de generación automática y se genera un palíndromo de longitud 1, en este caso también se tiene una complejidad de tiempo constante.\newline

\item Peor caso: El peor caso ocurre cuando se ingresa una longitud máxima de 100,000 caracteres y se genera un palíndromo completo. En este caso, el programa recorre iterativamente diferentes casos y selecciona aleatoriamente las reglas de producción hasta alcanzar la longitud deseada. La complejidad de tiempo en el peor caso está directamente relacionada con la longitud máxima permitida, por lo que podría considerarse lineal o cuasi-lineal.\newline

\item Complejidad de espacio: El espacio requerido por el programa depende de la longitud del palíndromo generado y la cantidad de pasos o reglas de producción utilizadas en su construcción. El programa almacena la cadena de construcción en una variable, así como en el archivo de salida 'construccion.txt'. Además, el palíndromo final se guarda en el archivo 'palindromos.txt'. Por lo tanto, la complejidad de espacio está relacionada con la longitud máxima del palíndromo y podría considerarse lineal.\newline
\end{enumerate}


Es importante tener en cuenta que estos límites de complejidad son una estimación general y podrían variar según las implementaciones específicas de Python y las características del entorno de ejecución. Además, la eficiencia del programa puede mejorarse mediante optimizaciones y técnicas avanzadas de generación de palíndromos.